# -*- coding: utf-8 -*-
"""Assignment2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15eL3pzsFhnWtLaV4nRZJU-V55iPiRLu-
"""

from google.colab import files


uploaded = files.upload()

import numpy as np
import pandas as pd
import os

df = pd.read_csv("Power_Consumption.csv")
data = df.to_numpy()
# take a look at the dataset
print(df.values)

for x in ["Global_active_power"]:
    q75,q25 = np.percentile(df.loc[:,x],[75,25])
    intr_qr = q75-q25
 
    maxi = q75+(1.5*intr_qr)
    mini = q25-(1.5*intr_qr)
    print("Outliers of ")
    #df.loc[df[x] > max,x]
    print(df[df[x] < mini])
    i = df[df[x] < mini].index
    df.drop(i)
    print()
    print(df[df[x] > maxi]) 
    i = df[df[x] > maxi].index
    df.drop(i)

for x in ["Global_reactive_power"]:
    q75,q25 = np.percentile(df.loc[:,x],[75,25])
    intr_qr = q75-q25
 
    maxi = q75+(1.5*intr_qr)
    mini = q25-(1.5*intr_qr)
    print("Outliers of ")
    #df.loc[df[x] > max,x]
    print(df[df[x] < mini])
    i = df[df[x] < mini].index
    df.drop(i)
    print()
    print(df[df[x] > maxi])
    i = df[df[x] > maxi].index
    df.drop(i) 


for x in ["Voltage"]:
    q75,q25 = np.percentile(df.loc[:,x],[75,25])
    intr_qr = q75-q25
 
    maxi = q75+(1.5*intr_qr)
    mini = q25-(1.5*intr_qr)
    print("Outliers of ")
    #df.loc[df[x] > max,x]
    print(df[df[x] < mini])
    i = df[df[x] < mini].index
    df.drop(i)
    print()
    print(df[df[x] > maxi])
    i = df[df[x] > maxi].index
    df.drop(i) 

for x in ["Sub_metering_1"]:
    q75,q25 = np.percentile(df.loc[:,x],[75,25])
    intr_qr = q75-q25
 
    maxi = q75+(1.5*intr_qr)
    mini = q25-(1.5*intr_qr)
    print("Outliers of ")
    #df.loc[df[x] > max,x]
    print(df[df[x] < mini])
    i = df[df[x] < mini].index
    df.drop(i)
    print()
    print(df[df[x] > maxi])
    i = df[df[x] > maxi].index
    df.drop(i) 

for x in ["Sub_metering_2"]:
    q75,q25 = np.percentile(df.loc[:,x],[75,25])
    intr_qr = q75-q25
 
    maxi = q75+(1.5*intr_qr)
    mini = q25-(1.5*intr_qr)
    print("Outliers of ")
    #df.loc[df[x] > max,x]
    print(df[df[x] < mini])
    i = df[df[x] < mini].index
    df.drop(i)
    print()
    print(df[df[x] > maxi])
    i = df[df[x] > maxi].index
    df.drop(i) 

for x in ["Sub_metering_3"]:
    q75,q25 = np.percentile(df.loc[:,x],[75,25])
    intr_qr = q75-q25
 
    maxi = q75+(1.5*intr_qr)
    mini = q25-(1.5*intr_qr)
    print("Outliers of ")
    #df.loc[df[x] > max,x]
    print(df[df[x] < mini])
    i = df[df[x] < mini].index
    df.drop(i)
    print()
    print(df[df[x] > maxi]) 
    i = df[df[x] > maxi].index
    df.drop(i)

import math
def manhatten(center, point):
    d = 0.0
    for i in range(0,len(point)):
        d += abs((center[i]-point[i]))
    return d

def dist(center, point):
    d = 0.0
    for i in range(0,len(point)):
        d += (center[i]-point[i])**2
    return math.sqrt(d)

def assignCenters(centers, dataset,type):
  if(type=="euqledian"):
    clusters = []
    for i in range(len(dataset)):
        distances = []
        for center in centers:
            distances.append(dist(center, dataset[i]))
        temp = [z for z, val in enumerate(distances) if val==min(distances)]
        clusters.append(temp[0])
    return clusters
  else:
    clusters = []
    for i in range(len(dataset)):
        distances = []
        for center in centers:
            distances.append(manhatten(center, dataset[i]))
        temp = [z for z, val in enumerate(distances) if val==min(distances)]
        clusters.append(temp[0])
    return clusters

def mean_center(k, dataset, clusters):
    nCenters = []
    for i in range(k):
        x = 0.0
        y = 0.0
        z= 0.0
        a= 0.0
        b=0.0
        c=0.0
        d=0.0
        e=0.0
        count = 0
        for j in range(len(clusters)):
            if(i == clusters[j]):
                x += dataset[j][0]
                y += dataset[j][1]
                z += dataset[j][2]
                a += dataset[j][3]
                b += dataset[j][4]
                c += dataset[j][5]
                d += dataset[j][6]
                e += dataset[j][7]
                
                count += 1
        x = x/count
        y = y/count
        z = z/count
        a = a/count
        b = b/count
        c = c/count
        d = d/count
        e = e/count
        nCenters.append([x,y,z,a,b,c,d,e])
    return nCenters
import random
def Randomize(k):
  centers = []
  centers = df.sample(n=k)
  centers = centers.to_numpy()
  return centers

print("enter k")
k = int(input())
centers = []
centers = Randomize(k)

print("enter type of calculating distance [manhatten or euqledian]")
Type=input()

print("Initial centers: ")
print(centers)

clusters = assignCenters(centers, data,str(Type))

while(True):
    old_centers=centers
    
    centers = mean_center(k,data,clusters)
    
    clusters = assignCenters(centers, data,str(Type))
    if(np.array_equal(centers,old_centers)):
      break;
    
        
for i in range(0,k):
        print("Center ",i)
        print(centers[i])
        print()
print("Final Cluster List : ")
print()
for i in range(k):
        print("cluster  "+str(i))
        for j in range(len(clusters)):
            if(i == clusters[j]):
                print(data[j],end=' ')
                print()